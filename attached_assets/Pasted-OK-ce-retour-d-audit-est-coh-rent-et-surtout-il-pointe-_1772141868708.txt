OK â€” ce retour dâ€™audit est cohÃ©rent et, surtout, il pointe exactement le vrai bug : DATABASE_URL arrive vide/undefined en prod (ou devient vide aprÃ¨s â€œcleaningâ€), et pg se casse la gueule en interne sur new URL(undefined) â†’ searchParams.

Maintenant on exÃ©cute proprement les tÃ¢ches T001â€“T004, en mode â€œpas de magie, que des preuvesâ€.

1) T001 â€” Rendre DATABASE_URL impossible Ã  foirer (et prouver quâ€™il est bien reÃ§u)
Ce quâ€™on veut

Si DATABASE_URL est manquant / vide / invalide â†’ log clair + exit(1) (pas de crash cryptique en runtime).

Au dÃ©marrage, tu vois un log du genre :

postgresql://cronos_app:***@db-postgresql-fra1-...:25060/cronosdb (sslmode stripped).

Patch recommandÃ© (logique)

Dans server/db.ts (ou lÃ  oÃ¹ tu construis le Pool) :

Lire process.env.DATABASE_URL (ou process.env.DATABASE_URL?.trim()).

Valider avant tout replace() :

non vide

commence par postgres:// ou postgresql://

Faire ton â€œcleanâ€ (retirer sslmode=...) sans jamais pouvoir produire une string vide.

Re-valider aprÃ¨s clean.

Log â€œmaskedâ€ (sans password) au boot.

process.exit(1) si invalide.

âš ï¸ Point clÃ© : ton cleaning doit gÃ©rer ces cas :

URL qui ne contient que ?sslmode=require (ou pire : quelquâ€™un a mis juste sslmode=require dans la variableâ€¦ oui, Ã§a arrive)

URL avec &sslmode=require

URL avec paramÃ¨tres multiples

Le plus robuste : parse en new URL() uniquement aprÃ¨s validation que câ€™est une URL, puis supprimer searchParams.delete("sslmode").

2) T003 â€” VÃ©rifier la variable sur DigitalOcean (câ€™est lÃ  que Ã§a casse)

Tu ne peux pas corriger du code si DO envoie un DATABASE_URL vide.

Sur DigitalOcean App Platform

App â†’ Settings â†’ Environment Variables

Cherche DATABASE_URL

Clique lâ€™Å“il (ou â€œEditâ€) pour vÃ©rifier que :

Ã§a commence bien par postgresql://...

il y a bien @db-postgresql-fra1-69239...:25060/

et le bon DB name (/cronosdb)

IMPORTANT

Si tu as crÃ©Ã© DATABASE_URL â€œEncryptedâ€, câ€™est OK.

Mais si tu as aussi une variable du style DATABASE__URL (double underscore) ou DB_URL, ton code peut lire la mauvaise.

Et si tu as â€œcomponent-level env varsâ€ qui override â€œapp-levelâ€, tu peux avoir un DATABASE_URL vide dans le Web Service.

ğŸ‘‰ AprÃ¨s patch T001, tu auras un log clair qui dira â€œDATABASE_URL missingâ€ au boot. Câ€™est exactement la preuve quâ€™on veut.

3) T002 â€” Corriger les routes auth pour renvoyer 503 au lieu de 500 â€œvagueâ€

Ã‡a ne rÃ¨gle pas le cÅ“ur du problÃ¨me, mais Ã§a te donne une prod qui se comporte comme un service sÃ©rieux :

DB down / non connectable â†’ 503 Service Unavailable

mauvais mot de passe â†’ 401

Donc dans server/routes.ts, sur :

/api/auth/login

/api/auth/employee-login

/api/auth/refresh

remplacer les console.error + res.status(500) par handleRouteError(err, req, res) (ou ton wrapper standard).

4) Ton Ã©tat actuel (dâ€™aprÃ¨s tes logs)

Tu as eu 3 phases :

SELF_SIGNED_CERT_IN_CHAIN â†’ DB refusÃ©e (TLS CA foireux)

Tu as mis NODE_TLS_REJECT_UNAUTHORIZED=0 â†’ la DB passe â†’ tu obtiens des 401 (ce qui prouve que DB et auth fonctionnent)

Maintenant tu as Cannot read properties of undefined (reading 'searchParams') â†’ Ã§a sent :

DATABASE_URL absent dans CE dÃ©ploiement prÃ©cis (ou mal injectÃ©e)

ou ton cleaning a transformÃ© en string vide

Conclusion brutale : ce nâ€™est plus un problÃ¨me TLS ; câ€™est un problÃ¨me dâ€™injection de variable dâ€™environnement (ou de parsing).

5) Ce que tu dois faire maintenant, pas Ã  pas (sans rÃ©flÃ©chir)
Ã‰tape A â€” VÃ©rifier la variable cÃ´tÃ© DO

DigitalOcean â†’ App â†’ Settings â†’ Environment Variables

Ouvre DATABASE_URL

Confirme quâ€™elle est bien complÃ¨te

Si tu vois vide ou suspect :

remets la valeur en copiant depuis ton cluster DB (Connection details â†’ connection string), et colle la ligne complÃ¨te.

Ã‰tape B â€” Patch T001 (code)

Ajoute validation + log masked + exit(1) dans server/db.ts

Commit + push â†’ DO rebuild

Ã‰tape C â€” Lire les logs aprÃ¨s dÃ©ploiement

Tu dois voir au boot :

[PG-SSL] ...

et surtout ton nouveau log style [PG-URL] masked=postgresql://cronos_app:***@.../cronosdb

Si tu vois :

[PG-URL][FATAL] DATABASE_URL missing/invalid
=> câ€™est DO qui nâ€™injecte pas la variable au bon scope.

Ã‰tape D â€” Corriger DO scope si besoin

Dans DO, vÃ©rifie si la variable est :

au niveau â€œApp-levelâ€

ou au niveau â€œComponent-levelâ€ (Web Service pojectrules)

Si elle nâ€™est quâ€™au App-level mais ton composant override, mets-la explicitement dans le composant.

6) Pour ta question â€œquel login/mdp tester ?â€

Aucun nouveau login magique nâ€™est crÃ©Ã© par ces manips.

Le login admin Ã  tester = celui qui existe en DB (table employees/admin selon ton modÃ¨le)

Tant que tu prends la mÃªme base cronosdb et le mÃªme code, les identifiants ne changent pas.

Si tu obtiens 401, Ã§a veut dire :

DB OK

le user existe ou pas / password mismatch
â†’ lÃ  on passe en mode DB : on vÃ©rifie lâ€™email exact + si le hash correspond. Mais ce nâ€™est pas lâ€™Ã©tape actuelle.

7) Et le DNS / ancien lien qui marche encore

Deux points rapides (sans poÃ©sie, juste la mÃ©canique) :

Si lâ€™ancien lien marche encore, câ€™est que son DNS pointe toujours vers lâ€™ancienne infra (ou cache DNS).

Pour â€œtuerâ€ lâ€™ancien lien, tu dois soit :

changer le DNS de ce domaine vers DO

ou mettre une redirection cÃ´tÃ© ancien hÃ©bergeur

ou dÃ©sactiver lâ€™ancien service (la vraie guillotine)

Mais on ne touche pas au DNS tant que lâ€™app DO nâ€™est pas stable.